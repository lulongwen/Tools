# JavaScript 面试题

作用域
	变量或函数可访问的一个范围，一个函数就是一个作用域，一个对象也是一个作用域 {}

全局作用域
	全部变量
	避免使用全局变量

	变量声明不用 var，直接给变量名赋值，例如 name = 'lucy'，就是全局变量
	全局变量是在整个文档里面都可以用，因为全局变量是 window的属性，window是全局对象，在任何地方都可以访问

局部作用域，局部变量
	局部变量，只能在声明的那个作用域里面使用，在外面用不到，因为垃圾回收机制
	变量或函数在函数内部声明的，他的作用只存在于声明的整个函数中，外部使用报错，因为垃圾回收机制

闭包
	函数嵌套函数，子函数可以访问父函数的变量，这时候，就产生了一个闭包的环境

预解析
	函数或变量，都会有一个提前预解析的过程；
	JS会先把函数或变量提前解析，
	解析到作用域的最上面，

预解析步骤
	1 先找 var function 关键字及参数
	2 先找到 var （声明的变量或参数），会给 var或函数赋值，默认 undefined，如果找到 function 会把整个代码块拿到

	3 把找到的var function 以及关键字拿到作用域的最上面（开始的位置）
	4 逐行解读代码

	函数声明可以被提前预解析，可以先声明再调用（有名函数）
	函数表达式（匿名函数）不会预解析，只能先声明，再调用，
		不可以先调用，再声明，不然会报错


JS垃圾回收机制

	购物车，一上来就获取 localStorage
	sessionStorage
		没有兄弟页面事件
		关闭页面就销毁

	函数身上的方法，叫做静态方法
	原型链查找原型方法

	递归，先进后出，函数没有执行完，后面的代码不会执行
		递归就是 堆 的过程 [5,4,3,2,1]
		栈，其他都是栈 [1,2,3,4,5]


this 是关键词，不能当做变量
this 是只读属性，不能修改 this的值
this指向
	事件  谁调用指向谁
	定时器 window
	new 当前实例
	call 对象不能调用call
	new 》定时器 》 事件

	匿名函数自执行，this指向 window
	this 指向当前对象
	函数外，this指向 window
	函数内，函数直接调用，this指向 window，被事件调用，并且是以被赋值的形式出现，谁调用了，this就指向谁


函数，既有原型，又有原型链
	对象，只有原型链 __proto__ 对象的原型 = 原型链
	原型链最终指向 Object

	new Object()
	new Array()
	new Function()
	函数的原型，只给实例化的对象使用，函数走原型链，找完 Function，还找 Object，Object没有就报错